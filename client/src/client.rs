//! The main DHCP client module.

use std::net::{
    IpAddr,
    Ipv4Addr,
    SocketAddr,
};

use tokio::{
    io,
    prelude::*,
};
use eui48::{
    MacAddress,
};
use chrono::prelude::*;
use rand;

use framed::{
    DhcpFramed,
    DHCP_PORT_SERVER,
    DHCP_PORT_CLIENT,
};
use message::MessageBuilder;

/// Is used if a server does not provide the `renewal_time` option.
const RENEWAL_TIME_FACTOR: f64      = 0.5;
/// Is used if a server does not provide the `rebinding_time` option.
const REBINDING_TIME_FACTOR: f64    = 0.875;

/// RFC 2131 DHCP states.
enum DhcpState {
    // from zero configuration sequence
    Init,
    Selecting,
    Requesting,
    // from not zero configuration sequence
    InitReboot,
    Rebooting,
    // configuration renewal/rebinding sequence (TODO)
    Renewing,
    Rebinding,
    // the final state
    Bound,
}

/// The result of the `Client` future.
struct State {
    /// The destination address, usually the `255.255.255.255` broadcast address or a known server address.
    pub destination     : SocketAddr,
    /// Current DHCP client state (RFC 2131).
    pub dhcp_state      : DhcpState,
    /// Generated by client for each session.
    pub transaction_id  : u32,
    /// If the client requires broadcast response (e.g. if it is not configured yet).
    pub is_broadcast    : bool,

    /// Recorded by client from the selected `DHCPOFFER`.
    pub offered_address : Ipv4Addr,
    /// Recorded by client from the selected `DHCPOFFER`.
    pub offered_time    : u32,

    /// Recorded by client right before sending the `DHCPREQUEST`.
    pub requested_at    : u32,
    /// Recorded by client from the `DHCPACK`.
    pub assigned_address: Ipv4Addr,
    /// Calculated by client from the `renewal_time` option or using the default factor.
    pub renewal_at      : u32,
    /// Calculated by client from the `rebinding_time` option or using the default factor.
    pub rebinding_at    : u32,
    /// Calculated by client from the `address_time` option from the `DHCPACK` message.
    pub expired_at      : u32,
}

/// May be used to request stuff explicitly.
struct RequestOptions {
    /// Explicit network address request.
    address_request     : Option<Ipv4Addr>,
    /// Explicit lease time request.
    address_time        : Option<u32>,
}

/// The `Client` future result type.
#[derive(Debug, Clone)]
pub struct Result {
    your_ip_address     : Ipv4Addr,
    server_ip_address   : Ipv4Addr,
    subnet_mask         : Option<Ipv4Addr>,
    routers             : Option<Vec<Ipv4Addr>>,
    domain_name_servers : Option<Vec<Ipv4Addr>>,
    static_routes       : Option<Vec<(Ipv4Addr, Ipv4Addr)>>,
}

/// The struct implementing the `Future` trait.
pub struct Client {
    socket              : DhcpFramed,
    message_builder     : MessageBuilder,
    state               : State,
    options             : RequestOptions,
    result              : Option<Result>,
}

impl Client {
    /// Creates a client future.
    ///
    /// * `client_hardware_address`
    /// The client's `MAC-48` hardware address.
    ///
    /// * `client_id`
    /// The optional client identifier.
    /// If not set, defaults to `client_hardware_address` bytes.
    ///
    /// * `server_address`
    /// The DHCP server address.
    /// Set it if your know the server address.
    /// If set, the client communicates with the server using unicast.
    /// Otherwise, broadcasting to 255.255.255.255 is used.
    ///
    /// * `client_address`
    /// The previous client address.
    /// Set it if you want to reacquire your previous network address.
    /// If set, the client is started in INIT-REBOOT state.
    /// If not set, the client is started in INIT state.
    ///
    /// * `address_request`
    /// The requested network address.
    /// Set it if you want to requested a static network address.
    /// If not set, the server will give you either
    /// your current or previous address, or an address from its dynamic pool.
    ///
    /// * `address_time`
    /// The requested lease time.
    /// If not set, the server will determine the lease time by itself.
    /// The server may lease the address for different amount time if it decides so.
    ///
    pub fn new(
        client_hardware_address : MacAddress,
        client_id               : Option<Vec<u8>>,
        server_address          : Option<Ipv4Addr>,
        client_address          : Option<Ipv4Addr>,
        address_request         : Option<Ipv4Addr>,
        address_time            : Option<u32>,
    ) -> io::Result<Self> {
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0,0,0,0)), DHCP_PORT_CLIENT);
        let socket = DhcpFramed::new(addr, false, false)?;

        /*
        RFC 2131 §4.4.4
        The DHCP client broadcasts DHCPDISCOVER, DHCPREQUEST and DHCPINFORM
        messages, unless the client knows the address of a DHCP server. The
        client unicasts DHCPRELEASE messages to the server. Because the
        client is declining the use of the IP address supplied by the server,
        the client broadcasts DHCPDECLINE messages.

        When the DHCP client knows the address of a DHCP server, in either
        INIT or REBOOTING state, the client may use that address in the
        DHCPDISCOVER or DHCPREQUEST rather than the IP broadcast address.
        The client may also use unicast to send DHCPINFORM messages to a
        known DHCP server.  If the client receives no response to DHCP
        messages sent to the IP address of a known DHCP server, the DHCP
        client reverts to using the IP broadcast address.
        */
        let (destination, is_broadcast) = if let Some(ip) = server_address {
            (ip, false)
        } else {
            (Ipv4Addr::new(255,255,255,255), true)
        };
        let destination = SocketAddr::new(IpAddr::V4(destination), DHCP_PORT_SERVER);

        let message_builder = MessageBuilder::new(
            client_hardware_address,
            client_id.unwrap_or(client_hardware_address.as_bytes().to_vec()),
        );

        let mut options = RequestOptions {
            address_request,
            address_time,
        };

        let dhcp_state = match client_address {
            Some(ip) => {
                options.address_request = Some(ip);
                DhcpState::InitReboot
            },
            None => DhcpState::Init,
        };

        let state = State {
            destination,
            dhcp_state,
            transaction_id      : rand::random::<u32>(),
            is_broadcast,

            offered_address     : Ipv4Addr::new(0,0,0,0),
            offered_time        : 0u32,
            requested_at        : 0u32,

            assigned_address    : Ipv4Addr::new(0,0,0,0),
            renewal_at          : 0u32,
            rebinding_at        : 0u32,
            expired_at          : 0u32,
        };

        Ok(Client {
            socket,
            message_builder,
            state,
            options,
            result: None,
        })
    }
}

macro_rules! start_send_or_panic(
    ($socket:expr, $address:expr, $message:expr) => (
        if let AsyncSink::NotReady(_) = $socket.start_send(($address, $message))? {
            panic!("Must wait for poll_complete first");
        }
    )
);

impl Future for Client {
    type Item = Option<Result>;
    type Error = io::Error;

    /// Works infinite time (TODO).
    ///
    ///               The DHCP client lifecycle (RFC 2131).
    ///  --------                               -------
    /// |        | +-------------------------->|       |<-------------------+
    /// | INIT-  | |     +-------------------->| INIT  |                    |
    /// | REBOOT |DHCPNAK/         +---------->|       |<---+               |
    /// |        |Restart|         |            -------     |               |
    ///  --------  |  DHCPNAK/     |               |                        |
    ///     |      Discard offer   |      -/Send DHCPDISCOVER               |
    /// -/Send DHCPREQUEST         |               |                        |
    ///     |      |     |      DHCPACK            v        |               |
    ///  -----------     |   (not accept.)/   -----------   |               |
    /// |           |    |  Send DHCPDECLINE |           |                  |
    /// | REBOOTING |    |         |         | SELECTING |<----+            |
    /// |           |    |        /          |           |     |DHCPOFFER/  |
    ///  -----------     |       /            -----------   |  |Collect     |
    ///     |            |      /                  |   |       |  replies   |
    /// DHCPACK/         |     /  +----------------+   +-------+            |
    /// Record lease, set|    |   v   Select offer/                         |
    /// timers T1, T2   ------------  send DHCPREQUEST      |               |
    ///     |   +----->|            |             DHCPNAK, Lease expired/   |
    ///     |   |      | REQUESTING |                  Halt network         |
    ///     DHCPOFFER/ |            |                       |               |
    ///     Discard     ------------                        |               |
    ///     |   |        |        |                   -----------           |
    ///     |   +--------+     DHCPACK/              |           |          |
    ///     |              Record lease, set    -----| REBINDING |          |
    ///     |                timers T1, T2     /     |           |          |
    ///     |                     |        DHCPACK/   -----------           |
    ///     |                     v     Record lease, set   ^               |
    ///     +----------------> -------      /timers T1,T2   |               |
    ///                +----->|       |<---+                |               |
    ///                |      | BOUND |<---+                |               |
    ///   DHCPOFFER, DHCPACK, |       |    |            T2 expires/   DHCPNAK/
    ///    DHCPNAK/Discard     -------     |             Broadcast  Halt network
    ///                |       | |         |            DHCPREQUEST         |
    ///                +-------+ |        DHCPACK/          |               |
    ///                     T1 expires/   Record lease, set |               |
    ///                  Send DHCPREQUEST timers T1, T2     |               |
    ///                  to leasing server |                |               |
    ///                          |   ----------             |               |
    ///                          |  |          |------------+               |
    ///                          +->| RENEWING |                            |
    ///                             |          |----------------------------+
    ///                              ----------
    ///
    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        use protocol::MessageType::*;

        loop {
            if let Async::NotReady = self.socket.poll_complete()? { return Ok(Async::NotReady); }

            match self.state.dhcp_state {
                DhcpState::Init => {
                    /*
                    RFC 2131 §4.4.1
                    The client begins in INIT state and forms a DHCPDISCOVER message.
                    The client MAY suggest a network address and/or lease time by including
                    the 'requested IP address' and 'IP address lease time' options.
                    */

                    let discover = self.message_builder.discover(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        self.options.address_request,
                        self.options.address_time,
                    );
                    info!("DHCPDISCOVER to {}:\n{}", self.state.destination, discover);
                    start_send_or_panic!(self.socket, self.state.destination, discover);
                    self.state.dhcp_state = DhcpState::Selecting;
                },
                DhcpState::Selecting => {
                    /*
                    RFC 2131 §4.4.1
                    If the parameters are acceptable, the client records the address of
                    the server that supplied the parameters from the 'server identifier'
                    field and sends that address in the 'server identifier' field of a
                    DHCPREQUEST broadcast message.
                    */

                    let (addr, response) = if let Some(item) = try_ready!(self.socket.poll()) { item } else { continue };
                    info!("Response from {}:\n{}", addr, response);
                    let dhcp_message_type = match response.validate() {
                        Ok(dhcp_message_type) => dhcp_message_type,
                        Err(_) => {
                            warn!("The request is invalid");
                            continue;
                        },
                    };

                    if response.transaction_id != self.state.transaction_id {
                        warn!(
                            "Got a response with different transaction ID: {} (yours is {})",
                            response.transaction_id,
                            self.state.transaction_id,
                        );
                        continue;
                    }

                    if let DhcpOffer = dhcp_message_type {} else {
                        warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                        continue;
                    }

                    let address_time = response.options.address_time
                        .expect("A bug in DHCP message validation");

                    self.state.destination = SocketAddr::new(
                        IpAddr::V4(response.server_ip_address),
                        DHCP_PORT_SERVER,
                    );
                    self.state.offered_address = response.your_ip_address;
                    self.state.offered_time = address_time;
                    self.state.requested_at = Utc::now().timestamp() as u32;

                    let request = self.message_builder.request_selecting(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        self.state.offered_address,
                        Some(self.state.offered_time),
                        response.server_ip_address,
                    );
                    info!("DHCPREQUEST to {}:\n{}", self.state.destination, request);
                    start_send_or_panic!(self.socket, self.state.destination, request);
                    self.state.dhcp_state = DhcpState::Requesting;
                },
                DhcpState::Requesting => {
                    /*
                    RFC 2131 §4.4.1
                    Once the DHCPACK message from the server arrives,
                    the client is initialized and moves to BOUND state.
                    */

                    let (addr, response) = if let Some(item) = try_ready!(self.socket.poll()) { item } else { continue };
                    info!("Response from {}:\n{}", addr, response);
                    let dhcp_message_type = match response.validate() {
                        Ok(dhcp_message_type) => dhcp_message_type,
                        Err(_) => {
                            warn!("The request is invalid");
                            continue;
                        },
                    };

                    if response.transaction_id != self.state.transaction_id {
                        warn!(
                            "Got a response with different transaction ID: {} (yours is {})",
                            response.transaction_id,
                            self.state.transaction_id,
                        );
                        continue;
                    }

                    match dhcp_message_type {
                        DhcpNak => {
                            warn!("Got DHCPNAK in REQUESTING state. Reverting to INIT state.");
                            self.state.destination = SocketAddr::new(
                                IpAddr::V4(Ipv4Addr::new(255,255,255,255)),
                                DHCP_PORT_SERVER,
                            );
                            self.state.dhcp_state = DhcpState::Init;
                            continue;
                        },
                        DhcpAck => {},
                        _ => {
                            warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                            continue;
                        },
                    }

                    let address_time = response.options.address_time
                        .expect("A bug in DHCP message validation");

                    self.state.assigned_address = response.your_ip_address;
                    self.state.renewal_at = self.state.requested_at + response.options.renewal_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * RENEWAL_TIME_FACTOR) as u32)
                    );
                    self.state.rebinding_at = self.state.requested_at + response.options.rebinding_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * REBINDING_TIME_FACTOR) as u32)
                    );
                    self.state.expired_at = self.state.requested_at + address_time;

                    self.result = Some(Result{
                        your_ip_address     : response.your_ip_address,
                        server_ip_address   : response.server_ip_address,
                        subnet_mask         : response.options.subnet_mask,
                        routers             : response.options.routers,
                        domain_name_servers : response.options.domain_name_servers,
                        static_routes       : response.options.static_routes,
                    });
                    self.state.dhcp_state = DhcpState::Bound;
                },

                DhcpState::InitReboot => {
                    /*
                    RFC 2131 §4.4.2
                    The client begins in INIT-REBOOT state and sends a DHCPREQUEST
                    message.  The client MUST insert its known network address as a
                    'requested IP address' option in the DHCPREQUEST message.
                    */

                    let address_request = self.options.address_request
                        .expect("A bug in the constructor");

                    let request = self.message_builder.request_init_reboot(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        address_request, // checked in constructor
                        self.options.address_time,
                    );
                    info!("DHCPREQUEST to {}:\n{}", self.state.destination, request);
                    start_send_or_panic!(self.socket, self.state.destination, request);
                    self.state.dhcp_state = DhcpState::Rebooting;
                },
                DhcpState::Rebooting => {
                    /*
                    RFC 2131 §4.4.2
                    Once a DHCPACK message with an 'xid' field matching that in the
                    client's DHCPREQUEST message arrives from any server, the client is
                    initialized and moves to BOUND state.
                    */

                    let (addr, response) = if let Some(item) = try_ready!(self.socket.poll()) { item } else { continue };
                    info!("Response from {}:\n{}", addr, response);
                    let dhcp_message_type = match response.validate() {
                        Ok(dhcp_message_type) => dhcp_message_type,
                        Err(_) => {
                            warn!("The request is invalid");
                            continue;
                        },
                    };

                    if response.transaction_id != self.state.transaction_id {
                        warn!(
                            "Got a response with different transaction ID: {} (yours is {})",
                            response.transaction_id,
                            self.state.transaction_id
                        );
                        continue;
                    }

                    match dhcp_message_type {
                        DhcpNak => {
                            warn!("Got DHCPNAK in REBOOTING state. Reverting to INIT-REBOOT state.");
                            self.state.destination = SocketAddr::new(
                                IpAddr::V4(Ipv4Addr::new(255,255,255,255)),
                                DHCP_PORT_SERVER,
                            );
                            continue;
                        },
                        DhcpAck => {},
                        _ => {
                            warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                            continue;
                        },
                    }

                    let address_time = response.options.address_time
                        .expect("A bug in DHCP message validation");

                    self.state.renewal_at = self.state.requested_at + response.options.renewal_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * RENEWAL_TIME_FACTOR) as u32)
                    );
                    self.state.rebinding_at = self.state.requested_at + response.options.rebinding_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * REBINDING_TIME_FACTOR) as u32)
                    );
                    self.state.expired_at = self.state.requested_at + address_time;

                    self.result = Some(Result{
                        your_ip_address     : response.your_ip_address,
                        server_ip_address   : response.server_ip_address,
                        subnet_mask         : response.options.subnet_mask,
                        routers             : response.options.routers,
                        domain_name_servers : response.options.domain_name_servers,
                        static_routes       : response.options.static_routes,
                    });
                    self.state.dhcp_state = DhcpState::Bound;
                },

                DhcpState::Bound => {
                    // TODO
                    return Ok(Async::Ready(self.result.to_owned()));
                },

                _ => {},
            }
        }
    }
}