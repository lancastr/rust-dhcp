//! The main DHCP client module.

use std::{
    net::{
        IpAddr,
        Ipv4Addr,
        SocketAddr,
    },
    time::{
        Duration,
    },
};

use tokio::{
    io,
    prelude::*,
};
use chrono::prelude::*;
use hostname;
use rand;

use framed::{
    DhcpFramed,
    DHCP_PORT_SERVER,
    DHCP_PORT_CLIENT,
};
use message::{
    MessageBuilder,
    ClientId,
};
use backoff::Backoff;

/// Is used if a server does not provide the `renewal_time` option.
const RENEWAL_TIME_FACTOR: f64 = 0.5;
/// Is used if a server does not provide the `rebinding_time` option.
const REBINDING_TIME_FACTOR: f64 = 0.875;
/// Initial timeout in seconds for waiting for DHCPOFFER messages.
const DHCPOFFER_TIMEOUT_INITIAL: u64 = 1;
/// Maximal timeout in seconds for waiting for DHCPOFFER messages.
const DHCPOFFER_TIMEOUT_MAXIMUM: u64 = 64;

/// RFC 2131 DHCP states.
enum DhcpState {
    // from zero configuration sequence
    Init,
    Selecting,
    Requesting,
    // from not zero configuration sequence
    InitReboot,
    Rebooting,
    // configuration renewal/rebinding sequence (TODO)
    Renewing,
    Rebinding,
    // the final state
    Bound,
}

/// The result of the `Client` future.
struct State {
    // Super-state data
    /// The destination address, usually the `255.255.255.255` broadcast address or a known server address.
    pub destination     : SocketAddr,
    /// Current DHCP client state (RFC 2131).
    pub dhcp_state      : DhcpState,
    /// Generated by client for each session.
    pub transaction_id  : u32,
    /// If the client requires broadcast response (e.g. if it is not configured yet).
    pub is_broadcast    : bool,

    // Data set in INIT or INIT-REBOOT state
    /// DHCPOFFER receive deadline.
    pub timer_selecting : Option<Backoff>,

    // Data set in SELECTING state
    /// Recorded by the client from the selected `DHCPOFFER`.
    pub offered_address : Ipv4Addr,
    /// Recorded by the client from the selected `DHCPOFFER`.
    pub offered_time    : u32,
    /// Recorded by the client right before sending the `DhcpRequest`.
    pub requested_at    : u32,

    // Data set in REQUESTING state
    /// Recorded by the client from the `DhcpAck`.
    pub assigned_address: Ipv4Addr,
    /// Calculated by the client from the `renewal_time` option or using the default factor.
    pub renewal_at      : u32,
    /// Calculated by the client from the `rebinding_time` option or using the default factor.
    pub rebinding_at    : u32,
    /// Calculated by the client from the `address_time` option from the `DhcpAck` message.
    pub expired_at      : u32,

    // Data set in INIT or INIT-REBOOT state
    /// DHCPOFFER receive deadline.
    pub timer_rebooting : Option<Backoff>,
}

/// May be used to request stuff explicitly.
struct RequestOptions {
    /// Explicit network address request.
    address_request     : Option<Ipv4Addr>,
    /// Explicit lease time request.
    address_time        : Option<u32>,
}

/// The `Client` future result type.
#[derive(Debug, Clone)]
pub struct Result {
    your_ip_address     : Ipv4Addr,
    server_ip_address   : Ipv4Addr,
    subnet_mask         : Option<Ipv4Addr>,
    routers             : Option<Vec<Ipv4Addr>>,
    domain_name_servers : Option<Vec<Ipv4Addr>>,
    static_routes       : Option<Vec<(Ipv4Addr, Ipv4Addr)>>,
}

/// The struct implementing the `Future` trait.
pub struct Client {
    socket              : DhcpFramed,
    message_builder     : MessageBuilder,
    state               : State,
    options             : RequestOptions,
    result              : Option<Result>,
}

impl Client {
    /// Creates a client future.
    ///
    /// * `client_id`
    /// The client identifier.
    /// May be either a MAC-48 or a custom byte array.
    ///
    /// * `hostname`
    /// May be explicitly set by a client user.
    /// Otherwise it is defaulted to the machine hostname.
    /// If the hostname cannot be get, remains unset.
    ///
    /// * `server_address`
    /// The DHCP server address.
    /// Set it if your know the server address.
    /// If set, the client communicates with the server using unicast.
    /// Otherwise, broadcasting to 255.255.255.255 is used.
    ///
    /// * `client_address`
    /// The previous client address.
    /// Set it if you want to reacquire your previous network address.
    /// If set, the client is started in INIT-REBOOT state.
    /// If not set, the client is started in INIT state.
    ///
    /// * `address_request`
    /// The requested network address.
    /// Set it if you want to requested a static network address.
    /// If not set, the server will give you either
    /// your current or previous address, or an address from its dynamic pool.
    ///
    /// * `address_time`
    /// The requested lease time.
    /// If not set, the server will determine the lease time by itself.
    /// The server may lease the address for different amount time if it decides so.
    ///
    pub fn new(
        client_id               : ClientId,
        hostname                : Option<String>,
        server_address          : Option<Ipv4Addr>,
        client_address          : Option<Ipv4Addr>,
        address_request         : Option<Ipv4Addr>,
        address_time            : Option<u32>,
    ) -> io::Result<Self> {
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0,0,0,0)), DHCP_PORT_CLIENT);
        let socket = DhcpFramed::new(addr, true, true, Some("eth0"))?;

        let hostname: Option<String> = if hostname.is_none() { hostname::get_hostname() } else { None };

        /*
        RFC 2131 §4.4.4
        The DHCP client broadcasts DhcpDiscover, DhcpRequest and DHCPINFORM
        messages, unless the client knows the address of a DHCP server. The
        client unicasts DHCPRELEASE messages to the server. Because the
        client is declining the use of the IP address supplied by the server,
        the client broadcasts DHCPDECLINE messages.

        When the DHCP client knows the address of a DHCP server, in either
        INIT or REBOOTING state, the client may use that address in the
        DhcpDiscover or DhcpRequest rather than the IP broadcast address.
        The client may also use unicast to send DHCPINFORM messages to a
        known DHCP server.  If the client receives no response to DHCP
        messages sent to the IP address of a known DHCP server, the DHCP
        client reverts to using the IP broadcast address.
        */
        let (destination, is_broadcast) = if let Some(ip) = server_address {
            (ip, false)
        } else {
            (Ipv4Addr::new(255,255,255,255), true)
        };
        let destination = SocketAddr::new(IpAddr::V4(destination), DHCP_PORT_SERVER);

        let message_builder = MessageBuilder::new(
            client_id,
            hostname,
        );

        let mut options = RequestOptions {
            address_request,
            address_time,
        };

        let dhcp_state = match client_address {
            Some(ip) => {
                options.address_request = Some(ip);
                DhcpState::InitReboot
            },
            None => DhcpState::Init,
        };

        let state = State {
            destination,
            dhcp_state,
            transaction_id      : 0u32,
            is_broadcast,

            timer_selecting     : None,

            offered_address     : Ipv4Addr::new(0,0,0,0),
            offered_time        : 0u32,
            requested_at        : 0u32,

            assigned_address    : Ipv4Addr::new(0,0,0,0),
            renewal_at          : 0u32,
            rebinding_at        : 0u32,
            expired_at          : 0u32,

            timer_rebooting     : None,
        };

        Ok(Client {
            socket,
            message_builder,
            state,
            options,
            result: None,
        })
    }
}

/// By design the pending message must be flushed before sending the next one.
macro_rules! start_send_or_panic(
    ($socket:expr, $address:expr, $message:expr) => (
        if let AsyncSink::NotReady(_) = $socket.start_send(($address, $message))? {
            panic!("Must wait for poll_complete first");
        }
    )
);

/// Just to move some code from the overwhelmed `poll` method.
macro_rules! poll_complete_or_continue (
    ($socket:expr) => (
        match $socket.poll_complete() {
            Ok(Async::Ready(_)) => {},
            Ok(Async::NotReady) => return Ok(Async::NotReady),
            Err(error) => {
                warn!("Socket error: {}", error);
                continue;
            },
        }
    )
);

/// Just to move some code from the overwhelmed `poll` method.
macro_rules! poll_or_continue (
    ($stream:expr) => (
        match $stream.poll() {
            Ok(Async::Ready(Some(data))) => data,
            Ok(Async::Ready(None)) => continue,
            Ok(Async::NotReady) => return Ok(Async::NotReady),
            Err(error) => {
                warn!("Stream error: {}", error);
                continue;
            },
        };
    )
);

/// Is safe after calling the `validate_or_continue` macro.
///
/// The passed `Option` must be already validated in
/// `protocol::Message::validate` method and be `Some(_)`.
macro_rules! unwrap_validated (
    ($option:expr) => (
        $option.expect("A bug in DHCP message validation")
    )
);

/// Just to move some code from the overwhelmed `poll` method.
macro_rules! check_transaction_id (
    ($yours:expr, $response:expr) => (
        if $response != $yours {
            warn!("Got a response with wrong transaction ID: {} (yours is {})", $response, $yours);
            continue;
        }
    )
);

/// Just to move some code from the overwhelmed `poll` method.
macro_rules! validate_or_continue (
    ($message:expr, $address:expr) => (
        match $message.validate() {
            Ok(dhcp_message_type) => dhcp_message_type,
            Err(error) => {
                warn!("The response from {} is invalid: {} {}", $address, error, $message);
                continue;
            },
        };
    )
);

impl Stream for Client {
    type Item = Result;
    type Error = io::Error;

    /// Works infinite time (TODO).
    ///
    ///               The DHCP client lifecycle (RFC 2131).
    ///  --------                               -------
    /// |        | +-------------------------->|       |<-------------------+
    /// | INIT-  | |     +-------------------->| INIT  |                    |
    /// | REBOOT |DhcpNak/         +---------->|       |<---+               |
    /// |        |Restart|         |            -------     |               |
    ///  --------  |  DhcpNak/     |               |                        |
    ///     |      Discard offer   |      -/Send DhcpDiscover               |
    /// -/Send DhcpRequest         |               |                        |
    ///     |      |     |      DhcpAck            v        |               |
    ///  -----------     |   (not accept.)/   -----------   |               |
    /// |           |    |  Send DHCPDECLINE |           |                  |
    /// | REBOOTING |    |         |         | SELECTING |<----+            |
    /// |           |    |        /          |           |     |DHCPOFFER/  |
    ///  -----------     |       /            -----------   |  |Collect     |
    ///     |            |      /                  |   |       |  replies   |
    /// DhcpAck/         |     /  +----------------+   +-------+            |
    /// Record lease, set|    |   v   Select offer/                         |
    /// timers T1, T2   ------------  send DhcpRequest      |               |
    ///     |   +----->|            |             DhcpNak, Lease expired/   |
    ///     |   |      | REQUESTING |                  Halt network         |
    ///     DHCPOFFER/ |            |                       |               |
    ///     Discard     ------------                        |               |
    ///     |   |        |        |                   -----------           |
    ///     |   +--------+     DhcpAck/              |           |          |
    ///     |              Record lease, set    -----| REBINDING |          |
    ///     |                timers T1, T2     /     |           |          |
    ///     |                     |        DhcpAck/   -----------           |
    ///     |                     v     Record lease, set   ^               |
    ///     +----------------> -------      /timers T1,T2   |               |
    ///                +----->|       |<---+                |               |
    ///                |      | BOUND |<---+                |               |
    ///   DHCPOFFER, DhcpAck, |       |    |            T2 expires/   DhcpNak/
    ///    DhcpNak/Discard     -------     |             Broadcast  Halt network
    ///                |       | |         |            DhcpRequest         |
    ///                +-------+ |        DhcpAck/          |               |
    ///                     T1 expires/   Record lease, set |               |
    ///                  Send DhcpRequest timers T1, T2     |               |
    ///                  to leasing server |                |               |
    ///                          |   ----------             |               |
    ///                          |  |          |------------+               |
    ///                          +->| RENEWING |                            |
    ///                             |          |----------------------------+
    ///                              ----------
    ///
    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        use protocol::MessageType::*;

        loop {
            poll_complete_or_continue!(self.socket);

            match self.state.dhcp_state {
                DhcpState::Init => {
                    /*
                    RFC 2131 §4.4.1
                    The client begins in INIT state and forms a DhcpDiscover message.
                    The client MAY suggest a network address and/or lease time by including
                    the 'requested IP address' and 'IP address lease time' options.
                    */

                    self.state.transaction_id = rand::random::<u32>();

                    let discover = self.message_builder.discover(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        self.options.address_request,
                        self.options.address_time,
                    );
                    info!("DhcpDiscover to {}: {}", self.state.destination, discover);
                    start_send_or_panic!(self.socket, self.state.destination, discover);

                    if self.state.timer_selecting.is_none() {
                        self.state.timer_selecting = Some(Backoff::new(
                            Duration::from_secs(DHCPOFFER_TIMEOUT_INITIAL),
                            Duration::from_secs(DHCPOFFER_TIMEOUT_MAXIMUM),
                        ));
                    }
                    self.state.dhcp_state = DhcpState::Selecting;
                },
                DhcpState::Selecting => {
                    /*
                    RFC 2131 §4.4.1
                    If the parameters are acceptable, the client records the address of
                    the server that supplied the parameters from the 'server identifier'
                    field and sends that address in the 'server identifier' field of a
                    DhcpRequest broadcast message.
                    */

                    // This boilerplate code queries the socket and the BEM timer for expiration.
                    let (mut addr, response) = match self.socket.poll() {
                        Ok(Async::Ready(Some(data))) => {
                            self.state.timer_selecting = None;
                            data
                        },
                        Ok(Async::Ready(None)) => {
                            warn!("Socket returned None");
                            continue;
                        },
                        Ok(Async::NotReady) => {
                            if let Some(ref mut timer) = self.state.timer_selecting {
                                match timer.poll() {
                                    Ok(Async::Ready(Some(_))) => return Err(io::Error::new(io::ErrorKind::TimedOut, "Timeout")),
                                    Ok(Async::Ready(None)) => {
                                        warn!("Reverting to INIT state");
                                        self.state.dhcp_state = DhcpState::Init;
                                        continue;
                                    },
                                    Ok(Async::NotReady) => return Ok(Async::NotReady),
                                    Err(error) => {
                                        warn!("Timer error: {}", error);
                                        continue;
                                    },
                                }
                            } else {
                                panic!("Timer is None in REQUESTING state");
                            }
                        },
                        Err(error) => {
                            warn!("Socket error: {}", error);
                            continue;
                        },
                    };

                    let dhcp_message_type = validate_or_continue!(response, addr);
                    info!("{:?} from {}: {}", dhcp_message_type, addr, response);
                    check_transaction_id!(self.state.transaction_id, response.transaction_id);

                    if let DhcpOffer = dhcp_message_type {} else {
                        warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                        continue;
                    }

                    let address_time = unwrap_validated!(response.options.address_time);
                    let dhcp_server_id = unwrap_validated!(response.options.dhcp_server_id);

                    self.state.destination = SocketAddr::new(
                        IpAddr::V4(dhcp_server_id),
                        DHCP_PORT_SERVER,
                    );
                    self.state.offered_address = response.your_ip_address;
                    self.state.offered_time = address_time;
                    self.state.requested_at = Utc::now().timestamp() as u32;

                    let request = self.message_builder.request_selecting(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        self.state.offered_address,
                        Some(self.state.offered_time),
                        dhcp_server_id,
                    );
                    info!("DhcpRequest to {}: {}", self.state.destination, request);
                    start_send_or_panic!(self.socket, self.state.destination, request);
                    self.state.dhcp_state = DhcpState::Requesting;
                },
                DhcpState::Requesting => {
                    /*
                    RFC 2131 §4.4.1
                    Once the DhcpAck message from the server arrives,
                    the client is initialized and moves to BOUND state.
                    */

                    let (mut addr, response) = poll_or_continue!(self.socket);
                    let dhcp_message_type = validate_or_continue!(response, addr);
                    info!("{:?} from {}: {}", dhcp_message_type, addr, response);
                    check_transaction_id!(self.state.transaction_id, response.transaction_id);

                    match dhcp_message_type {
                        DhcpNak => {
                            warn!("Got DhcpNak in REQUESTING state. Reverting to INIT state.");
                            self.state.destination = SocketAddr::new(
                                IpAddr::V4(Ipv4Addr::new(255,255,255,255)),
                                DHCP_PORT_SERVER,
                            );
                            self.state.dhcp_state = DhcpState::Init;
                            continue;
                        },
                        DhcpAck => {},
                        _ => {
                            warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                            continue;
                        },
                    }

                    let address_time = unwrap_validated!(response.options.address_time);

                    self.state.assigned_address = response.your_ip_address;
                    self.state.renewal_at = self.state.requested_at + response.options.renewal_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * RENEWAL_TIME_FACTOR) as u32)
                    );
                    self.state.rebinding_at = self.state.requested_at + response.options.rebinding_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * REBINDING_TIME_FACTOR) as u32)
                    );
                    self.state.expired_at = self.state.requested_at + address_time;

                    self.result = Some(Result{
                        your_ip_address     : response.your_ip_address,
                        server_ip_address   : response.server_ip_address,
                        subnet_mask         : response.options.subnet_mask,
                        routers             : response.options.routers,
                        domain_name_servers : response.options.domain_name_servers,
                        static_routes       : response.options.static_routes,
                    });
                    self.state.dhcp_state = DhcpState::Bound;
                },

                DhcpState::InitReboot => {
                    /*
                    RFC 2131 §4.4.2
                    The client begins in INIT-REBOOT state and sends a DhcpRequest
                    message.  The client MUST insert its known network address as a
                    'requested IP address' option in the DhcpRequest message.
                    */

                    self.state.transaction_id = rand::random::<u32>();

                    let address_request = unwrap_validated!(self.options.address_request);

                    let request = self.message_builder.request_init_reboot(
                        self.state.transaction_id,
                        self.state.is_broadcast,
                        address_request, // checked in constructor
                        self.options.address_time,
                    );
                    info!("DhcpRequest to {}: {}", self.state.destination, request);
                    start_send_or_panic!(self.socket, self.state.destination, request);

                    if self.state.timer_rebooting.is_none() {
                        self.state.timer_rebooting = Some(Backoff::new(
                            Duration::from_secs(DHCPOFFER_TIMEOUT_INITIAL),
                            Duration::from_secs(DHCPOFFER_TIMEOUT_MAXIMUM),
                        ));
                    }
                    self.state.dhcp_state = DhcpState::Rebooting;
                },
                DhcpState::Rebooting => {
                    /*
                    RFC 2131 §4.4.2
                    Once a DhcpAck message with an 'xid' field matching that in the
                    client's DhcpRequest message arrives from any server, the client is
                    initialized and moves to BOUND state.
                    */

                    // This boilerplate code queries the socket and the BEM timer for expiration.
                    let (mut addr, response) = match self.socket.poll() {
                        Ok(Async::Ready(Some(data))) => {
                            self.state.timer_rebooting = None;
                            data
                        },
                        Ok(Async::Ready(None)) => {
                            warn!("Socket returned None");
                            continue;
                        },
                        Ok(Async::NotReady) => {
                            if let Some(ref mut timer) = self.state.timer_rebooting {
                                match timer.poll() {
                                    Ok(Async::Ready(Some(_))) => {
                                        warn!("Reverting to INIT state");
                                        self.state.dhcp_state = DhcpState::Init;
                                        continue;
                                    },
                                    Ok(Async::Ready(None)) => {
                                        warn!("Reverting to INIT-REBOOT state");
                                        self.state.dhcp_state = DhcpState::InitReboot;
                                        continue;
                                    },
                                    Ok(Async::NotReady) => return Ok(Async::NotReady),
                                    Err(error) => {
                                        warn!("Timer error: {}", error);
                                        continue;
                                    },
                                }
                            } else {
                                panic!("Timer is None in REBOOTING state");
                            }
                        },
                        Err(error) => {
                            warn!("Socket error: {}", error);
                            continue;
                        },
                    };

                    let dhcp_message_type = validate_or_continue!(response, addr);
                    info!("{:?} from {}: {}", dhcp_message_type, addr, response);
                    check_transaction_id!(self.state.transaction_id, response.transaction_id);

                    match dhcp_message_type {
                        DhcpNak => {
                            warn!("Got DhcpNak in REBOOTING state. Reverting to INIT-REBOOT state.");
                            self.state.destination = SocketAddr::new(
                                IpAddr::V4(Ipv4Addr::new(255,255,255,255)),
                                DHCP_PORT_SERVER,
                            );
                            continue;
                        },
                        DhcpAck => {},
                        _ => {
                            warn!("Got an unexpected DHCP message type {:?}", dhcp_message_type);
                            continue;
                        },
                    }

                    let address_time = unwrap_validated!(response.options.address_time);

                    self.state.renewal_at = self.state.requested_at + response.options.renewal_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * RENEWAL_TIME_FACTOR) as u32)
                    );
                    self.state.rebinding_at = self.state.requested_at + response.options.rebinding_time.unwrap_or(
                        self.state.requested_at + (((address_time as f64) * REBINDING_TIME_FACTOR) as u32)
                    );
                    self.state.expired_at = self.state.requested_at + address_time;

                    self.result = Some(Result{
                        your_ip_address     : response.your_ip_address,
                        server_ip_address   : response.server_ip_address,
                        subnet_mask         : response.options.subnet_mask,
                        routers             : response.options.routers,
                        domain_name_servers : response.options.domain_name_servers,
                        static_routes       : response.options.static_routes,
                    });
                    self.state.dhcp_state = DhcpState::Bound;
                },

                DhcpState::Bound => {
                    // TODO
                    self.state.dhcp_state = DhcpState::Init;
                    return Ok(Async::Ready(self.result.to_owned()));
                },

                _ => {},
            }
        }
    }
}